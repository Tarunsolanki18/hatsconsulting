-- Supabase SQL schema for the app
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  email text,
  photo_url text,
  is_deleted boolean default false,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

create table if not exists public.earnings (
  user_id uuid primary key references public.profiles(id) on delete cascade,
  today integer default 0,
  week integer default 0,
  total integer default 0,
  pending_adjustments integer default 0,
  updated_at timestamp with time zone default now()
);

create table if not exists public.reports (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  report_type text not null check (report_type in ('account_open', 'trade')),
  application_name text not null,
  customer_name text not null,
  mobile_number text not null,
  status text default 'Pending' check (status in ('Pending', 'Checked', 'Rejected')),
  trade_done boolean default false,
  payment_status text default 'Not Paid' check (payment_status in ('Not Paid', 'Paid', 'Pending')),
  payment_proof_url text,
  trade_proof_url text,
  notes text,
  admin_notes text,
  is_deleted boolean default false,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

create table if not exists public.campaigns (
  id bigint generated by default as identity primary key,
  name text not null,
  campaign_type text not null check (campaign_type in ('account_open', 'trade')),
  logo_url text,
  payout_with_trade text,
  payout_without_trade text,
  referral_link text,
  account_open_video text,
  trade_video text,
  view_details text,
  is_live boolean default false,
  start_date timestamp with time zone,
  end_date timestamp with time zone,
  notes text,
  impressions integer default 0,
  is_deleted boolean default false,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- Admin audit log for tracking admin actions
create table if not exists public.admin_audit_log (
  id bigint generated by default as identity primary key,
  admin_id uuid references public.profiles(id),
  action_type text not null,
  entity_type text not null,
  entity_id text not null,
  previous_state jsonb,
  new_state jsonb,
  ip_address text,
  created_at timestamp with time zone default now()
);

-- Security codes for login/approval
create table if not exists public.security_codes (
  code text primary key,
  note text,
  active boolean default true,
  expires_at timestamp with time zone,
  created_at timestamp with time zone default now()
);

-- Admin emails allowlist
create table if not exists public.admin_emails (
  email text primary key
);

-- Storage bucket for proofs
-- In Supabase UI: create a public bucket named "proofs"

-- RLS
alter table public.profiles  enable row level security;
alter table public.earnings  enable row level security;
alter table public.reports   enable row level security;
alter table public.campaigns enable row level security;
alter table public.security_codes enable row level security;

-- profiles policies
drop policy if exists "profiles are readable by self" on public.profiles;
create policy "profiles are readable by self" on public.profiles
for select using (auth.uid() = id);
drop policy if exists "profiles insert by user" on public.profiles;
create policy "profiles insert by user" on public.profiles
for insert with check (auth.uid() = id);
drop policy if exists "profiles update by self" on public.profiles;
create policy "profiles update by self" on public.profiles
for update using (auth.uid() = id);
drop policy if exists "profiles update by admin" on public.profiles;
create policy "profiles update by admin" on public.profiles
for update using (exists (select 1 from public.admin_emails a where a.email = auth.email()));
drop policy if exists "profiles readable by admin" on public.profiles;
create policy "profiles readable by admin" on public.profiles
for select using (exists (select 1 from public.admin_emails a where a.email = auth.email()));

-- earnings policies
drop policy if exists "earnings read own" on public.earnings;
create policy "earnings read own" on public.earnings
for select using (auth.uid() = user_id);
drop policy if exists "earnings read by admin" on public.earnings;
create policy "earnings read by admin" on public.earnings
for select using (exists (select 1 from public.admin_emails a where a.email = auth.email()));
drop policy if exists "earnings upsert by admin" on public.earnings;
create policy "earnings upsert by admin" on public.earnings
for insert with check (exists (select 1 from public.admin_emails a where a.email = auth.email()));
drop policy if exists "earnings update by admin" on public.earnings;
create policy "earnings update by admin" on public.earnings
for update using (exists (select 1 from public.admin_emails a where a.email = auth.email()));

-- campaigns policies
drop policy if exists "campaigns are publicly readable" on public.campaigns;
create policy "campaigns are publicly readable" on public.campaigns
for select using (true);
drop policy if exists "campaigns write by admin" on public.campaigns;
create policy "campaigns write by admin" on public.campaigns
for all using (exists (select 1 from public.admin_emails a where a.email = auth.email()))
with check (exists (select 1 from public.admin_emails a where a.email = auth.email()));

-- security_codes policies (admin-only management)
drop policy if exists "codes select by admin" on public.security_codes;
create policy "codes select by admin" on public.security_codes
for select using (exists (select 1 from public.admin_emails a where a.email = auth.email()));
drop policy if exists "codes insert by admin" on public.security_codes;
create policy "codes insert by admin" on public.security_codes
for insert with check (exists (select 1 from public.admin_emails a where a.email = auth.email()));
drop policy if exists "codes update by admin" on public.security_codes;
create policy "codes update by admin" on public.security_codes
for update using (exists (select 1 from public.admin_emails a where a.email = auth.email()));
drop policy if exists "codes delete by admin" on public.security_codes;
create policy "codes delete by admin" on public.security_codes
for delete using (exists (select 1 from public.admin_emails a where a.email = auth.email()));

-- reports policies
drop policy if exists "reports read own" on public.reports;
create policy "reports read own" on public.reports
for select using (auth.uid() = user_id);
drop policy if exists "reports insert by owner" on public.reports;
create policy "reports insert by owner" on public.reports
for insert with check (auth.uid() = user_id);
drop policy if exists "reports read by admin" on public.reports;
create policy "reports read by admin" on public.reports
for select using (exists (select 1 from public.admin_emails a where a.email = auth.email()));
drop policy if exists "reports update by admin" on public.reports;
create policy "reports update by admin" on public.reports
for update using (exists (select 1 from public.admin_emails a where a.email = auth.email()));

-- admin-only RPC to reload PostgREST schema cache
create or replace function public.reload_schema()
returns void
language plpgsql
security definer
set search_path = public
as $$
begin
  if not exists (select 1 from public.admin_emails a where a.email = auth.email()) then
    raise exception 'not allowed';
  end if;
  perform pg_notify('pgrst', 'reload schema');
end;
$$;

-- RPC to approve with code (also acts as code validation on login)
create or replace function public.approve_with_code(p_code text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_uid uuid;
  v_now timestamptz := now();
begin
  select auth.uid() into v_uid;
  if v_uid is null then
    raise exception 'not authenticated';
  end if;
  return exists(
    select 1 from public.security_codes c
    where c.code = p_code
      and c.active = true
      and (c.expires_at is null or c.expires_at >= v_now)
  );
end;
$$;

-- NOTE: Admin updates are performed from the admin page using anon key. For secure production, prefer creating Postgres functions with 'security definer' and calling via supabase.rpc with checks on auth.email() in a safe allowlist.


